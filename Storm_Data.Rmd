---
title: "Economic Consequences & Population Health Hazards of Severe Weather"
author: "EHarris"
date: "6/06/2017"
output: 
  html_document: 
    keep_md: yes
---

## Load anticipated packages to be used throughout Course 5 Project 1
```{r setup, include=FALSE}
ipak <- function(pkg){
      new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
      if (length(new.pkg)) 
            install.packages(new.pkg, dependencies = TRUE)
      sapply(pkg, require, character.only = TRUE)
}

### Package Usage
packages <- c("plyr", "dplyr", "data.table", "dtplyr", "lubridate", "ggplot2", "scales",
                  "reshape2", "knitr", "R.cache", "stringr", "gtools", "quantreg")
ipak(packages)
```

## Analysis Synopsis
Due to the different types, and serverity, of weather experienced throughout a country, 
there is a desire to understand weather events that create the greatest economic 
consequences or most hazardous with respect to population health.  

We will be using data provided by the National Oceanic and Atmospheric Administration 
(NOAA) to help answer these questions.  Economic consequences are measured by the amount 
of damage, property and/or crop, that is associated with each event type.  The population 
health hazard is measured by the number of fatalities and/or injuries with an event.  The 
number of fatalities will be the primary metric for determining the population health 
hazard.

## Data Processing  
A first step to our analysis is reading the data into R from the working directory. The data provided is a zipped csv file.  We unzip and read into R using read.csv file.  The code to read in the file, as well as a couple summaries of the data.

#### Read zipped csv file into R
```{r read_storm_data, include = TRUE, cache = TRUE}
StormData <- read.csv("repdata-data-StormData.csv.bz2", header = TRUE, sep = ",",
                        quote = "\"", dec = ".")

##### A quick overview of the data in this file:
dim(StormData)

str(StormData)
```

#### Subset the data
The size of the dataset provided is rather large, but much of the data is not very useful 
to answering the stated questions, or goals.  The following steps are taken to subset the 
dataset to the variables, and dates, that are relevent to the analysis.  This subset 
also facilitates the effort to clean-up the data for further review and analysis.

##### Date / time variables
There are two areas for clean-up, or defining subset, of the original file with respect 
to dates and/or times provided.  Key to these decisions to include or remove is whether 
the information supports the analysis.

** An overview of event time from the National Weather Service:  
"In general, the time of an event, as it appears in the header-strip, is the time when 
the event reached locally, regionally, or nationally established advisory or warning 
criteria (exceptions defined in Section 2.3.1). The event time could be the single time 
that a peak wind gust of 65 knots (75 mph) occurred, or it could be beginning and ending 
times of a 10-minute shower of large, damaging hailstones. If the time of the event in 
the header-strip is a broad guesstimate,then it should be indicated as such in the event 
narrative."

The first step is evaluating the quality of the data.  For each EVTYPE and REFNUM, a 
unique reporting instance provided in data file, a BGN_DATE, BGN_TIME, END_DATE, and 
END_TIME.  The BGN_DATE, BGN_TIME, along with a TIME_ZONE are consistently populated.  
This is not true for END_DATE and END_TIME.  As there is not a good way to populate or 
impute appropriate values, these variables provide little value towards analyziing the 
event types in the dataset.  These veariables, therefore, will be removed from subset.
```{r missing_end_dates, include = TRUE, echo = FALSE}
no.missing <- sum(ifelse(StormData$END_DATE %in% c("", " ", "NA", "NaN"), 1, 0))
pct.missing <- sum(ifelse(StormData$END_DATE %in% c("", " ", "NA", "NaN"), 1,0))/
                                                            length(StormData$END_DATE)
```
For END_DATE, there are `r no.missing` missing dates, or `r pct.missing` percent of total.

The other consideration for dates / times is relevance of the data.  The data includes 
dates between 1950 - 2011.  Because of shifting populations over time the data for events 
prior to 1990 are not as relevant to evaluating the economic consequences or hazards to 
population health represented by an event. Data for dates prior to 1990 are removed from 
the subset.

##### Format dates to exclude experience prior to 1990
```{r event_dates, include = TRUE}
StormData$BGN_DATE <- as.Date(StormData$BGN_DATE, "%m/%d/%Y")
StormData$BGN_YEAR <- format(StormData$BGN_DATE, "%Y")
StormData$hour <- as.numeric(substr(StormData$BGN_TIME, 1, 2))
StormData$minute <- substr(StormData$BGN_TIME, 3, 4)
StormData$ampm <- ifelse(StormData$hour > 12, "PM", "AM")
StormData$hour <- ifelse(StormData$hour > 12, StormData$hour - 12, 
                              ifelse(StormData$hour < 1, 12, StormData$hour))
StormData$hour <- substr(paste("00", StormData$hour, sep = ""), 
                         min(length(StormData$hour)+1,3),min(length(StormData$hour)+2, 4))

StormData$BGN_TIME <- paste(StormData$hour, ":", StormData$minute, " ", 
                                                      StormData$ampm, sep = "")
```
NOTE:  Although BGN_TIME & TIME_ZONE are not critical to analysis, they will be included 
in the subset of the data.

##### Defining the location or area for an event
There are four variables -- STATE, COUNTYNAME, LATITUDE, & LONGITUDE --  
that are well-populated and could be used to support analysis by location.  Only these 4  
variables are included in final, tidy,  dataset to be used for analysis.  Other location  
related variables are sparsely populated.

NOTE:  Location is not used in the final analysis for determining the event type with the 
greatest economic consequences or hazard to population health.  Results will evaluated 
across all markets combined.

#### Creating the subset
We will not be keeping many of the poorly populated variables provided in the zip file  
we received.  They do not lend themselves to a further understanding of the questions  
for analysis.  

The final processing of the dataset is to limit the final dataset to data to BGN_Dates  
on or after "1990-01-01".  Although data captures events as early as 1950, there have  
been significant shifts in population density and development that may distort results  
by including the earlier years.
```{r subset_storm_data, include = TRUE, cache = TRUE}
subStormData <- select(StormData, REFNUM, BGN_YEAR, BGN_DATE, BGN_TIME, TIME_ZONE,
                       STATE, COUNTYNAME, LATITUDE, LONGITUDE, EVTYPE, F, MAG,
                       FATALITIES, INJURIES, PROPDMG, PROPDMGEXP, CROPDMG, CROPDMGEXP)
subStormData <- subset(subStormData, BGN_YEAR > "1989")
subStormData <- subStormData[order(subStormData$STATE, subStormData$COUNTYNAME,
                                    subStormData$EVTYPE, subStormData$BGN_DATE),]
```

##### Create Econonmic Consequencences metric for each event, event type & REFNUM
To facilitate analysis, it is necessary to modify the orginal data in some cases.  As an  
example, the dollar amounts for property damage are expressed in different denomiations  
(e.g. thousand vs. millions of dollars).  It is important to define a consistent measure  
so that dollars can be combined, or summed, for different levels of aggregation, as  
appropriate.
```{r economic_measure, include = TRUE}
subStormData$PROPDMG <- subStormData$PROPDMG * ifelse(subStormData$PROPDMGEXP 
                                                            %in% c("h","H"), 100,
                        ifelse(subStormData$PROPDMGEXP %in% c("k", "K"), 1000,
                        ifelse(subStormData$PROPDMGEXP %in% c("m", "M"), 1000000,
                        ifelse(subStormData$PROPDMGEXP %in% c("b", "B"), 1000000000, 1))))
subStormData$CROPDMG <- subStormData$CROPDMG * ifelse(subStormData$CROPDMGEXP 
                                                            %in% c("h","H"), 100,
                        ifelse(subStormData$CROPDMGEXP %in% c("k", "K"), 1000,
                        ifelse(subStormData$CROPDMGEXP %in% c("m", "M"), 1000000,
                        ifelse(subStormData$CROPDMGEXP %in% c("b", "B"), 1000000000, 1))))
subStormData$TTLDMG <- subStormData$PROPDMG + subStormData$CROPDMG
subStormData <- select(subStormData, -c(PROPDMGEXP, CROPDMGEXP))
```

### Standardizing Event Type
```{r unique_evtype_in_data, include = FALSE}
events <- length(unique(subStormData$EVTYPE))
```
In the dataset provided, there are `r events` unique EVTYPE, defining the types of events 
that have occurred.  According to the National Weather Service Instruction 10-165 
released on August 17, 2007, events should fit into one of 48 event types or categories.  

The following steps reflect an effort to more consistently define the actual list of 
event types in the data with recommended list.  This represents a 'best effort' to 
improve the quality of the data.  Ideally, a mapping would be provided by the owner of 
the dataset to ensure a more accurrate cross-walk.  
```{r event_type_clean_up, include = TRUE}
subStormData$EVENT_TYPE <- ifelse(grepl("TORNADO", subStormData$EVTYPE, 
                                          ignore.case = TRUE), "Tornado",
                              ifelse(grepl("TYPHOON", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Hurricane(Typhoon)",
                              ifelse(grepl("HURRICAN", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Hurricane",
                              ifelse(grepl("TSUNAMI", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Tsunami",
                              ifelse(grepl("FUNNEL", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Funnel Cloud",
                              ifelse(grepl("AVALANCHE", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Avalanche",
                              ifelse(grepl("BLIZZARD", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Blizzard",
                              ifelse(grepl("MARINE HAIL", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Marine Hail",
                              ifelse(grepl("MARINE HIGH WIND", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Marine High Wind",
                              ifelse(grepl("MARINE STRONG WIND", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Marine Strong Wind",
                              ifelse(grepl("MARUNE THUNDERSTORM", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Marine Thunderstorm Wind",
                              ifelse(grepl("THUNDERSTORM", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Thunderstorm Wind",
                              ifelse(grepl("TSTM", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Thunderstorm Wind",
                              ifelse(grepl("HAIL", subStormData$EVTYPE,
                                          ignore.case = TRUE), "HAIL",
                              ifelse(grepl("EXTREME COLD", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Extreme Cold/Wind Chill",
                              ifelse(grepl("EXTREME WIND CHILL", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Extreme Cold/Wind Chill",
                              ifelse(grepl("COLD", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Cold/Wind Chill",
                              ifelse(grepl("WIND CHILL", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Cold/Wind Chill",
                              ifelse(grepl("FOG", subStormData$EVTYPE,
                                          ignore.case = TRUE), 
                                          ifelse(grepl("FREEZ", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Freezing Fog",
                                                "Dense Fog"),
                              ifelse(grepl("FLOOD", subStormData$EVTYPE,
                                          ignore.case = TRUE),
                                          ifelse(grepl("LAKE", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Lakeshore Flood",
                                          ifelse(grepl("FLASH", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Flash Flood",
                                          ifelse(grepl("COASTAL", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Coastal Flood",
                                          ifelse(grepl("SHORE", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Coastal Flood",
                                                "Flood")))),
                              ifelse(grepl("FIRE", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Wildfire",
                              ifelse(grepl("DROUGHT", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Drought",
                              ifelse(grepl("DRY", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Drought",
                              ifelse(grepl("HEAT", subStormData$EVTYPE,
                                          ignore.case = TRUE),
                                          ifelse(grepl("EXCESSIVE", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Excessive Heat",
                                                "Heat"),
                              ifelse(grepl("LIGHTNING", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Lightning",
                              ifelse(grepl("SNOW", subStormData$EVTYPE,
                                          ignore.case = TRUE),
                                          ifelse(grepl("LAKE", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Lake-effect Snow",
                                          ifelse(grepl("HEAVY", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Heavy Snow",
                                          ifelse(grepl("SLEET", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Winter Weather",
                                          ifelse(grepl("ICE", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Winter Weather",
                                          ifelse(grepl("RAIN", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Winter Weather",
                                                "Winter Storm"))))),
                              ifelse(grepl("HOT", subStormData$EVTYPE,
                                          ignore.case = TRUE), "HEAT",
                              ifelse(grepl("DUST", subStormData$EVTYPE,
                                          ignore.case = TRUE),
                                          ifelse(grepl("DEVIL", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Dust Devil",
                                                      "Dust Storm"),
                              ifelse(grepl("FROST", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Frost / Freeze",
                              ifelse(grepl("FREEZE", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Frost / Freeze",
                              ifelse(grepl("ICE ROADS", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Frost / Freeze",
                              ifelse(grepl("SLEET", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Sleet",
                              ifelse(grepl("VOLCANIC", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Volcanic Ash",
                              ifelse(grepl("RAIN", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Heavy Rain",
                              ifelse(grepl("WET", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Heavy Rain",
                              ifelse(grepl("MICROBURST", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Strong Wind",
                              ifelse(grepl("Wind", subStormData$EVTYPE,
                                          ignore.case = TRUE), 
                                          ifelse(grepl("HIGH", subStormData$EVTYPE,
                                                ignore.case = TRUE), "High Wind",
                                          ifelse(grepl("STRONG", subStormData$EVTYPE,
                                                ignore.case = TRUE), "Strong Wind",
                                                "High Wind")),
                              ifelse(grepl("PRECIPITATION", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Heavy Rain",
                              ifelse(grepl("FLD", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Flood",
                              ifelse(grepl("ASTRONOMICAL LOW TIDE", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Astronomical Low Tide",
                              ifelse(grepl("ASTRONOMICAL HIGH TIDE", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Coastal Flood",
                              ifelse(grepl("SURGE", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Storm Surge/Tide",
                              ifelse(grepl("TIDE", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Storm Surge/Tide",
                              ifelse(grepl("EROSION", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Storm Surge/Tide",
                              ifelse(grepl("FREEZING DRIZZLE", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Sleet",
                              ifelse(grepl("HEAVY SHOWER", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Heavy Rain",
                              ifelse(grepl("LOW TEMP", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Cold/Wind Chill",
                              ifelse(grepl("WINTER MIX", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Winter Weather",
                              ifelse(grepl("COASTALSTORM", subStormData$EVTYPE,
                                          ignore.case = TRUE), "Tropical Storm",
                  "Other Event")))))))))))))))))))))))))))))))))))))))))))))))))

unique.events <- length(unique(subStormData$EVENT_TYPE))  ## uniqe events in subset
events1 <- subset(subStormData, EVENT_TYPE == "Other Event")  ## Other event dataset
other.obs <- length(events1$EVENT_TYPE)  ## Total observations in 'Other Event' dataset
sub.obs <- length(subStormData$EVENT_TYPE)   ##Total observations in data subset
pct.other <- other.obs / sub.obs    ## Percent of observations captured in 'Other Event'
```

The mapping or cross-walk logic outlined above reduces the `r events` unique events 
orginally defined in the Storm Data subset, subStormData, to only `r unique.events`.  
This includes 41 of the 48 defined event types plus a catch-all 'Other Event' category.  
Only `r pct.other` of the events, or observations, were not assigned to a specific 
category, but 'Other Event'.


## Analysis
With a cleaner dataset, we are prepared to perform the analysis to answer the proposed 
questions, economic consequences and hazard to population health.  Each is reviewed 
separately.  All observations, representing dates between 1990 - 2011, are used in the 
analysis.  It is recognized that, in some cases, an event will not have much, if any, 
activity in any given year.  To include / exclude observations because of this fluctuation 
may misrepresent the effect, or impact, of an event.

#### Economic Consequences of an Event
For this analysis, the metric to assess the event type generating the greatest 'economonic 
consequence' is the combined cost for property damage (PROPDMG) and crop damage (CROPDMG). 
The combined field is named 'TTLDMG'.
```{r economic_consequences, include = TRUE}
economic.sum <- aggregate(TTLDMG ~ EVENT_TYPE, data = subStormData, 
                                    FUN = function(x) sum=sum(x))
economic.sum <- economic.sum[order(economic.sum$TTLDMG, decreasing = TRUE),]
economic.sum$TTLDMG_M <- round(economic.sum$TTLDMG / 1000000, digits = 2)
economic.sum$DOLLARS <- dollar(economic.sum$TTLDMG_M) 

economic.rpt <- select(economic.sum, EVENT_TYPE, DOLLARS)

#### Economic Consequences (in Millions of Dollars)
economic.rpt

```

#### Hazard to Population Health of an Event
It is understandable to think that both fatalities and injuries represent a hazard to 
population health.  The challenge, however, is making a comparison between events to 
identify the greatest hazard.  For our analysis, we decided that the number of fatalities 
represents the primary metric to measure the hazard level of an event.  If two events 
have the same number of fatalities, injuries are considered in the assessment.  


##### Calculations of key metrics noted above
```{r hazard_population_health, include = TRUE}
fatality.sum <- aggregate(FATALITIES ~ EVENT_TYPE, data = subStormData, 
                                    FUN = function(x) sum=sum(x))
fatality.sum <- fatality.sum[order(fatality.sum$FATALITIES, decreasing = TRUE),]


injury.sum <- aggregate(INJURIES ~ EVENT_TYPE, data = subStormData, 
                                    FUN = function(x) sum=sum(x))
injury.sum <- injury.sum[order(injury.sum$INJURIES, decreasing = TRUE),]


pophlth.sum <- merge(fatality.sum, injury.sum, by.x = "EVENT_TYPE")
pophlth.sum <- pophlth.sum[order(pophlth.sum$FATALITIES, pophlth.sum$INJURIES,
                                                decreasing = TRUE),]

pophlth.sum
```



##### Plot results for each of the top 20 Event Types
```{r plot_metrics_by_event, fig.keep = "all", fig.show = "asis", fig.path = 'figure/'}
par(mfrow = c(2, 2), mar = c(4, 4, 2, 1), oma = c(0, 0, 2, 0))
theme_update(plot.title = element.text(hjust = 0.5))
qplot(BGN_YEAR, ECONOMIC_MILL, data = event.economic.sum, color = EVTYPE, 
                  geom = c("point", "smooth"),
                  main = "Total Economic Consequence by Event (1980 - 2011)", 
                  xlab = "Measurement Year", ylab = "Total Cost (in Millions)")
qplot(BGN_YEAR, ECONOMIC_MILL, data = event.economic.mean, color = EVTYPE, 
                  geom = c("point", "smooth"),
                  main = "Average Economic Consequence per Occurrence (1980 - 2011)", 
                  xlab = "Measurement Year", ylab = "Average Cost (in Millions)")
qplot(BGN_YEAR, FATALITIES, data = event.fatalities.sum, color = EVTYPE, 
                  geom = c("point", "smooth"),
                  main = "Total Fatalities by Event (1980 - 2011)", 
                  xlab = "Measurement Year", ylab = "Total Fatalities")
qplot(BGN_YEAR, FATALITIES, data = event.fatalities.mean, color = EVTYPE, 
                  geom = c("point", "smooth"),
                  main = "Average Fatalities per Occurrence (1980 - 2011)", 
                  xlab = "Measurement Year", ylab = "Average Fatalities")


ggplot(event.economic, aes(x = factor(BGN_YEAR), y = ECONOMIC_THSND, colour = EVTYPE)) +
      geom_line() +
      geom_point() +
      labs(title = "Economic Consequences of Weather Event") +
      labs(x = "Measurement Year", y = "Economic Cost")
```



